/* 
 * Project  SPEED_MONITOR
 * Author:  ADRIAN MONTOYA
 * Date:    15 APRIL 2025 
 */

// Include Particle Device OS APIs
#include "Particle.h"
#include "neopixel.h"
#include "Colors.h"
#include <Adafruit_MQTT.h>
#include "Adafruit_MQTT/Adafruit_MQTT_SPARK.h"
#include "Adafruit_MQTT/Adafruit_MQTT.h"
#include "Adafruit_GFX.h"
#include "Adafruit_SSD1306.h"
#include "credentials.h"

const int MATRIX_PIN = D2;
const int MATRIX_WIDTH = 16;
const int MATRIX_HEIGHT = 16;
const int NUM_PIXELS = (MATRIX_WIDTH * MATRIX_HEIGHT);
const int LED_TYPE = WS2812B;

Adafruit_NeoPixel matrix = Adafruit_NeoPixel(NUM_PIXELS, SPI1, LED_TYPE);

// HC-SR04 sensor pins
const int TRIG_A = D8;    // Trigger pin sensor 1
const int ECHO_A = D9;    // Echo pin sensor 1
const int TRIG_B = D7;    // Trigger pin sensor 2
const int ECHO_B = D6;    // Echo pin sensor 2
const int LED_PIN = D4;   // LED to show object identified

const float SENSOR_DISTANCE_METERS = 0.61;
const float MPS_TO_MPH = 2.23694;
const float DETECTION_THRESHOLD_CM = 91.44;   // 3 feet

unsigned long triggerTimeA = 0;
unsigned long triggerTimeB = 0;
bool waitingForB = false;
unsigned long debounceDelay = 1000;

// Movement counters
int walkingCount = 0;
int runningCount = 0;
int cyclingCount = 0;

// In order to use sensors in both directions
enum SensorState { NONE, A_FIRST, B_FIRST };
SensorState triggeredSensor = NONE;

// Simple 5x7 font for digits
const byte numbers[10][5] = {
  {0x3E, 0x51, 0x49, 0x45, 0x3E}, {0x00, 0x42, 0x7F, 0x40, 0x00},
  {0x62, 0x51, 0x49, 0x49, 0x46}, {0x22, 0x49, 0x49, 0x49, 0x36},
  {0x18, 0x14, 0x12, 0x7F, 0x10}, {0x2F, 0x49, 0x49, 0x49, 0x31},
  {0x3E, 0x49, 0x49, 0x49, 0x32}, {0x01, 0x71, 0x09, 0x05, 0x03},
  {0x36, 0x49, 0x49, 0x49, 0x36}, {0x26, 0x49, 0x49, 0x49, 0x3E}
};

// Adafruit Display 
const int OLED_RESET = -1;
Adafruit_SSD1306 display(OLED_RESET);
const int LOGO16_GLCD_HEIGHT = 64;
const int LOGO16_GLCD_WIDTH = 128;
const int XPOS = 0;
const int YPOS = 1;


/************ Global State (you don't need to change this!) ***   ***************/ 
TCPClient TheClient; 

// Setup the MQTT client class by passing in the WiFi client and MQTT server and login details. 
Adafruit_MQTT_SPARK mqtt(&TheClient,AIO_SERVER,AIO_SERVERPORT,AIO_USERNAME,AIO_KEY); 

/****************************** Feeds ***************************************/ 
// Setup Feeds to publish or subscribe 
// Notice MQTT paths for AIO follow the form: <username>/feeds/<feedname> 
// Adafruit_MQTT_Subscribe subFeed = Adafruit_MQTT_Subscribe(&mqtt, AIO_USERNAME "/feeds/button"); 
Adafruit_MQTT_Publish pubMPH = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/biketrail");
Adafruit_MQTT_Publish pubWALK = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/walking");
Adafruit_MQTT_Publish pubRUN = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/running");
Adafruit_MQTT_Publish pubBIKE = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/cycling");

static const unsigned char logo16_glcd_bmp[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    };
    
// FUNCTIONS
uint16_t getPixelIndex(uint8_t x, uint8_t y);
void clearMatrix();
void drawDigit(int digit, int xOffset, int yOffset, uint32_t color);
void showSpeed(float speedMPH, uint32_t color);
float measureDistance(int trigPin, int echoPin);
void handleSpeed(float speedMph);
void MQTT_connect();
bool MQTT_ping();
void pubAdafruit(float speedMPH, int walk, int run, int bike);
    
#if (SSD1306_LCDHEIGHT != 64)
#error("Height incorrect, please fix Adafruit_SSD1306.h!");
#endif

void testdrawbitmap(const uint8_t *bitmap, uint8_t w, uint8_t h);

// Let Device OS manage the connection to the Particle Cloud
SYSTEM_MODE(SEMI_AUTOMATIC);

// Run the application and system concurrently in separate threads
SYSTEM_THREAD(ENABLED);

// Show system, cloud connectivity, and application logs over USB
// View logs with CLI using 'particle serial monitor --follow'
SerialLogHandler logHandler(LOG_LEVEL_INFO);

// setup() runs once, when the device is first turned on
void setup() {
  // setup ultrasonic sensor
  pinMode(TRIG_A,OUTPUT);
  pinMode(ECHO_A,INPUT);
  pinMode(TRIG_B,OUTPUT);
  pinMode(ECHO_B,INPUT);
  pinMode(LED_PIN,OUTPUT);

  // start serial monitor
  Serial.begin (9600);
  waitFor(Serial.isConnected,10000); 

  // Connect to Internet but not Particle Cloud
  WiFi.on();
  WiFi.connect();
  while(WiFi.connecting()) {
    Serial.printf(".");
  }
  Serial.printf("\n\n");

  // by default, we'll generate the high voltage from the 3.3v line internally! (neat!)
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3D (for the 128x64)
  // init done
  
  // text display tests
  display.clearDisplay();
  display.display();
  display.clearDisplay();
  display.drawBitmap(0, 0,  logo16_glcd_bmp, LOGO16_GLCD_WIDTH, LOGO16_GLCD_HEIGHT, WHITE);
  display.display();
  display.display();
  delay(3000);
  
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(40,0);
  display.print("Speed");
  display.setCursor(40,24);
  display.print("Radar");
  display.setCursor(40,48);
  display.print("Ready");
  display.display();
  delay(5000);

  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(25,0);
  display.print("Waiting");
  display.setCursor(50,24);
  display.print("For");
  display.setCursor(30,48);
  display.print("Object");
  display.display();

  matrix.begin();
  matrix.show();
}

// loop() runs over and over again, as quickly as it can execute.
void loop() {
  MQTT_connect();
  MQTT_ping();

  digitalWrite(LED_PIN,LOW);                                              // led on board to show object detected

  float distA = measureDistance(TRIG_A, ECHO_A);
  float distB = measureDistance(TRIG_B, ECHO_B);
  unsigned long now = millis();

  // Detect first sensor
  if (triggeredSensor == NONE) {
    if (distA < DETECTION_THRESHOLD_CM && triggeredSensor == NONE && now - triggerTimeA > debounceDelay) {
      triggerTimeA = now;
      triggeredSensor = A_FIRST;
    } else if (distB < DETECTION_THRESHOLD_CM && triggeredSensor == NONE && now - triggerTimeB > debounceDelay) {
      triggerTimeB = now;
      triggeredSensor = B_FIRST;
    }
  }

  // Detect second sensor and calculate speed
  if (triggeredSensor == A_FIRST && distB < DETECTION_THRESHOLD_CM && now - triggerTimeB > debounceDelay) {
    triggerTimeB = now;
    float timeSec = (triggerTimeB - triggerTimeA) / 1000.0;
    float speedMph = (SENSOR_DISTANCE_METERS / timeSec) * MPS_TO_MPH;
    handleSpeed(speedMph);
    triggeredSensor = NONE;
  } else if (triggeredSensor == B_FIRST && distA < DETECTION_THRESHOLD_CM && now - triggerTimeA > debounceDelay) {
    triggerTimeA = now;
    float timeSec = (triggerTimeA - triggerTimeB) / 1000.0;
    float speedMph = (SENSOR_DISTANCE_METERS / timeSec) * MPS_TO_MPH;
    handleSpeed(speedMph);
    triggeredSensor = NONE;
  }
  delay(50);
}

// FUNCTIONS
uint16_t getPixelIndex(uint8_t x, uint8_t y) {
  y = MATRIX_HEIGHT - 1 - y; // Flip Y
  if (y % 2 == 0) return y * MATRIX_WIDTH + x;
  else return y * MATRIX_WIDTH + (MATRIX_WIDTH - 1 - x);
}

void clearMatrix() {
  for (int i = 0; i < NUM_PIXELS; i++) {
    matrix.setPixelColor(i, 0);
  }
  matrix.show();
}

void drawDigit(int digit, int xOffset, int yOffset, uint32_t color) {
  for (int col = 0; col < 5; col++) {
    byte column = numbers[digit][col];
    for (int row = 0; row < 7; row++) {
      if (column & (1 << row)) {
        int x = xOffset + col;
        int y = yOffset + row;
        if (x >= 0 && x < MATRIX_WIDTH && y >= 0 && y < MATRIX_HEIGHT)
          matrix.setPixelColor(getPixelIndex(x, y), color);
      }
    }
  }
}

void showSpeed(float speedMPH, uint32_t color) {
  clearMatrix();
  int whole = int(speedMPH);
  int tens = whole / 10;
  int ones = whole % 10;

  // Total width of 2 digits = 5 + 1 + 5 = 11
  int totalWidth = 11;
  int xOffset = (MATRIX_WIDTH - totalWidth) / 2;
  int yOffset = (MATRIX_HEIGHT - 7) / 2;

  drawDigit(tens, xOffset, yOffset, color);
  drawDigit(ones, xOffset + 6, yOffset, color);
  matrix.show();
}

float measureDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH);
  return duration * 0.0343 / 2;
}

void handleSpeed(float speedMph) {
  String category;
  uint32_t color;

  if (speedMph < 4.5) {
    category = "Walking";
    color = matrix.Color(0,255,0);
    walkingCount++;
  } else if (speedMph <= 10.0) {
    category = "Running";
    color = matrix.Color(255,255,0);
    runningCount++;
  } else {
    category = "Cycling";
    if(speedMph > 10.0 && speedMph < 18.0) {
      color = matrix.Color(0,255,0);
    }
    else {
      color = matrix.Color(255,0,0);
    }
    }
    cyclingCount++;

  Serial.printf("Speed: %.2f mph â€” %s\n", speedMph, category.c_str());
  Serial.printf("W: %d, R: %d, C: %d\n", walkingCount, runningCount, cyclingCount);

  digitalWrite(LED_PIN,HIGH);                                              // led on board to show object detected

  // write to OLED
  display.clearDisplay();
  display.setCursor(0,0);
  display.setTextSize(2);
  display.printf("Speed: \n%0.1f mph\n",speedMph);
  display.setTextSize(1);
  display.setCursor(0,35);
  display.printf("Walking: %d\n", walkingCount);
  display.setCursor(0,45);
  display.printf("Running: %d\n", runningCount);
  display.setCursor(0,55);
  display.printf("Cycling: %d\n", cyclingCount);
  display.display();

  showSpeed(speedMph, color);
  delay(2000);
  clearMatrix();

  // publish to Adafruit
  pubAdafruit(speedMph,walkingCount,runningCount,cyclingCount);
}

// Function to connect and reconnect as necessary to the MQTT server.
// Should be called in the loop function and it will take care if connecting.
void MQTT_connect() {
  int8_t ret;
 
  // Return if already connected.
  if (mqtt.connected()) {
    return;
  }
 
  Serial.print("Connecting to MQTT... ");
 
  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected
       Serial.printf("Error Code %s\n",mqtt.connectErrorString(ret));
       Serial.printf("Retrying MQTT connection in 5 seconds...\n");
       mqtt.disconnect();
       delay(5000);  // wait 5 seconds and try again
  }
  Serial.printf("MQTT Connected!\n");
}

bool MQTT_ping() {
  static unsigned int last;
  bool pingStatus;

  if ((millis()-last)>120000) {
      Serial.printf("Pinging MQTT \n");
      pingStatus = mqtt.ping();
      if(!pingStatus) {
        Serial.printf("Disconnecting \n");
        mqtt.disconnect();
      }
      last = millis();
  }
  return pingStatus;
}

void pubAdafruit(float speedMPH, int walk, int run, int bike) {
  static unsigned lastTime = -999999;
  unsigned int currentTime;
  
  currentTime = millis();

  if((currentTime - lastTime > 5000)) {
    if(mqtt.Update()) {
      pubMPH.publish(speedMPH);
      Serial.printf("Publishing %0.2f \n",speedMPH); 
      pubWALK.publish(walk);
      Serial.printf("Publishing %i \n",walk); 
      pubRUN.publish(run);
      Serial.printf("Publishing %i \n",run); 
      pubBIKE.publish(bike);
      Serial.printf("Publishing %i \n",bike); 
      } 
    lastTime = millis();
  }
}
